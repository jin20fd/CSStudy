## [알고리즘 수업 - 깊이 우선 탐색 1](https://www.acmicpc.net/problem/24479)

### 문제 풀이 방식

정점 간의 정보들은 DFS와 BFS 문제와 동일하게 인접리스트 방식으로 처리하였습니다.

**방문한 순서를 dfs의 인자로 전달**

반례가 떠오르지 않아서 질문게시판에서 반례를 찾아내었습니다.

아래 예시의 경우에는 4까지는 예상한 대로 출력이 되지만,   
dfs(4)까지 호출한 이후에 다시 dfs(1)로 돌아오면 정점 5의 방문 순서가 5가 아닌 2로 잘못 출력되었습니다.

```
5 6 1
1 4
1 2
2 3
2 4
3 4
5 1 
```
**-> 방문 순서를 함수의 인자가 아닌 전역 변수로 변경하여 해결하였습ㄴ다.**

## [ABCDE](https://www.acmicpc.net/problem/13023)
### 문제 풀이 방식
**최대 깊이가 4를 넘는지**  
DFS 시작 지점에 따라서 최대 깊이가 달라지기 때문에, 모든 수를 시작지점으로 설정해보며 DFS로 탐색하며 최대 깊이를 구하였습니다.  
이렇게 구해진 최대 깊이가 4 이상이면 문제의 조건을 만족한다고 판단하여 1, 그렇지 않으면 0을 출력하도록 하였습니다.  

반례가 떠오르지 않아 질문게시판에서 반례를 찾아보았습니다.  
문제의 조건은 만족하지만 탐색의 최대 깊이는 4를 넘지 않는 경우였습니다.
```
5 5
0 1
1 3
1 4
4 3
3 2
```
해당 예시는 `0-1, 1-3, 3-2, 3-4` 이렇게 서로의 친구에 해당하며 문제의 조건을 만족합니다.  
제가 작성한 로직에 따라서 0부터 방문하는 경우를 살펴보면 방문 순서는 다음과 같고, 괄호에 있는 수가 깊이에 해당합니다.  
`0(0) -> 1(1) -> 3(2) -> 4(3) -> 2(3)`  
2는 4와 친구가 아니라 3과 친구이기 때문에 깊이가 4가 아닌 3이 됩니다.  
시작 원소를 바꾸어 다른 수로 확인해보아도 동일하게 깊이를 4를 넘지 못합니다.  

즉, 어떤 원소를 먼저 방문하냐에 따라서 최대 깊이가 달라지는 문제가 있었습니다.


**백트래킹 추가**  

그래서 3과 연결된 노드 중에 2가 아닌 4를 먼저 방문하면 0 -> 4 -> 3 -> 2 순으로 방문할 수 있기 때문에 백트래킹으로 확인였습니다.  
백트래킹을 적용하면서 전부 탐색을 하면 시간초과가 되기 때문에 깊이가 4를 넘으면 바로 result 플래그를 1로 변경하고 return 하도록 해주었습니다.


## [DFS 스페셜 저지](https://www.acmicpc.net/problem/16964)
### 문제 풀이 방식
정점들의 정보를 nodes라는 배열에 인접 리스트 형태로 저장하였습니다.  
주어진 방문 순서들을 두번째 정점부터 확인하면서 그 이전에 방문한 노드의 이웃인지 확인하는 방식으로 가능한 순서인지를 확인하였습니다.
그러나 이 방법의 경우, 최악의 경우 O(N^2)의 시간 복잡도를 가지고 문제에서 주어진 최대의 N은 10만이기 때문에 시간초과가 발생하였습니다..


